#! /bin/sh
np=1
while [ 1 -le $# ] ; do
  arg=$1
  #echo $arg
  #echo $#
  shift
  case $arg in 
    -np)
	np="$1"
        nodigits=`echo $np | sed 's/^[0-9]*$//'`
        if [ "$nodigits" != "" -o $np -lt 1 ] ; then
           echo np: $np is an invalid number of processors.  Exiting.
           exit 1
	fi
	eval np$narch=$1
	shift
	;;
    -v)
       	mpirun_verbose=1
	;;
    -t)
      	just_testing=1
	Show=echo
	;;
    -maxtime|-cpu)
        max_time="$1"
	shift
	;;
    -nopoll)
	polling_mode=0
	;;
    -mvhome)
	# discard
	;;
    -mvback)
	# discard
	shift
	;;
    -echo)
	# this is for debugging
	set -x
	;;
    *)
	# The first unrecognized argument is assumed to be the name of
      	# the program, but only if it is executable
	proginstance=`echo $arg | sed "s/%a/$arch/g"`
      	if [ "$progname" = "" -a "$fake_progname" = "" -a \
		! -x "$proginstance" ] ; then
	    fake_progname="$arg"
      	elif [ "$progname" = "" -a -x "$proginstance" ] ; then 
	    progname="$arg"
            # any following unrecognized arguments are assumed to be arguments
            # to be passed to the program, as well as all future args
	    # We can't use use_execer here to decide how to store the
	    # arguments, since we may later change it (see the switch on arch)
	    # Thus we store the args in tow forms
	    while [ 1 -le $# ] ; do
               cmdLineArgsExecer="$cmdLineArgsExecer -arg=$1"
               cmdLineArgs="$cmdLineArgs $1"
	       shift
            done
         else
	    echo "Warning: Command line arguments for program should be given"
            echo "after the program name.  Assuming that $arg is a"
            echo "command line argument for the program."
            cmdLineArgsExecer="$cmdLineArgsExecer -arg=$arg"
            cmdLineArgs="$cmdLineArgs $arg"
         fi
      ;;
  esac
done
#
/usr/bin/mpirun -np $np $progname $cmdLineArgs
